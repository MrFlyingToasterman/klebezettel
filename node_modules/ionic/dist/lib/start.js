"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const zlib = require("zlib");
const tar = require("tar");
const chalk = require("chalk");
const cli_utils_1 = require("@ionic/cli-utils");
function tarXvfFromUrl(url, destination, timeout, { progress }) {
    return new Promise((resolve, reject) => {
        const archiveRequest = cli_utils_1.createRequest('get', url)
            .timeout({ response: timeout ? 120000 : 0 })
            .on('response', (res) => {
            if (res.statusCode !== 200) {
                reject(new Error(`Encountered bad status code (${res.statusCode}) for ${url}\n` +
                    `This could mean the server is experiencing difficulties right now--please try again later.\n\n` +
                    `If you're behind a firewall, you can proxy requests by using the HTTP_PROXY or IONIC_HTTP_PROXY environment variables.`));
            }
            if (progress) {
                let loaded = 0;
                const total = Number(res.headers['content-length']);
                res.on('data', (chunk) => {
                    loaded += chunk.length;
                    progress(loaded, total);
                });
            }
        })
            .on('error', (err) => {
            if (err.code === 'ECONNABORTED') {
                reject(new Error(`Timeout of ${err.timeout}ms reached for ${url}`));
            }
            else {
                reject(err);
            }
        });
        tarXvf(archiveRequest, destination).then(resolve, reject);
    });
}
exports.tarXvfFromUrl = tarXvfFromUrl;
function tarXvf(readStream, destination) {
    return new Promise((resolve, reject) => {
        const baseArchiveExtract = tar.Extract({
            path: destination,
            strip: 1
        })
            .on('error', reject)
            .on('end', resolve);
        try {
            readStream
                .on('error', reject)
                .pipe(zlib.createUnzip())
                .pipe(baseArchiveExtract);
        }
        catch (e) {
            reject(e);
        }
    });
}
exports.tarXvf = tarXvf;
function isProjectNameValid(name) {
    return name !== '.';
}
exports.isProjectNameValid = isProjectNameValid;
function isSafeToCreateProjectIn(root) {
    return __awaiter(this, void 0, void 0, function* () {
        const validFiles = [
            '.DS_Store', 'Thumbs.db', '.git', '.gitignore', '.idea', 'README.md', 'LICENSE'
        ];
        const entries = yield cli_utils_1.fsReadDir(root);
        return entries.every((file) => {
            return validFiles.indexOf(file) >= 0;
        });
    });
}
exports.isSafeToCreateProjectIn = isSafeToCreateProjectIn;
function getStarterTemplateText(templateList) {
    let headerLine = chalk.bold(`Ionic Starter templates`);
    let formattedTemplateList = getStarterTemplateTextList(templateList);
    return `
    ${headerLine}
      ${formattedTemplateList.join(`
      `)}
  `;
}
exports.getStarterTemplateText = getStarterTemplateText;
function getStarterTemplateTextList(templateList) {
    return templateList.map(({ name, type, description }) => {
        let templateName = chalk.green(name);
        return `${templateName} ${Array(20 - name.length).join(chalk.dim('.'))} ${chalk.bold(type)} ${description}`;
    });
}
exports.getStarterTemplateTextList = getStarterTemplateTextList;
function getHelloText() {
    return `
${chalk.bold('♬ ♫ ♬ ♫  Your Ionic app is ready to go! ♬ ♫ ♬ ♫')}

${chalk.bold('Run your app in the browser (great for initial development):')}
  ${chalk.green('ionic serve')}

${chalk.bold('Run on a device or simulator:')}
  ${chalk.green('ionic cordova run ios')}

${chalk.bold('Test and share your app on a device with the Ionic View app:')}
  http://view.ionic.io
  `;
}
exports.getHelloText = getHelloText;
function patchPackageJsonForCli(appName, starterType, pathToProject) {
    return __awaiter(this, void 0, void 0, function* () {
        const patchPackagePath = path.resolve(pathToProject, 'patch.package.json');
        const packagePath = path.resolve(pathToProject, 'package.json');
        let pkg;
        let patch;
        try {
            pkg = yield cli_utils_1.fsReadJsonFile(packagePath);
        }
        catch (e) {
            if (e === cli_utils_1.ERROR_FILE_NOT_FOUND) {
                throw new Error(`${packagePath} is not valid JSON.`);
            }
            else if (e === cli_utils_1.ERROR_FILE_INVALID_JSON) {
                throw new Error(`${packagePath} is not valid JSON.`);
            }
            throw e;
        }
        try {
            patch = yield cli_utils_1.fsReadJsonFile(patchPackagePath);
            const lodash = cli_utils_1.load('lodash');
            let finalPackage = lodash.merge(pkg, patch);
            yield cli_utils_1.fsWriteJsonFile(packagePath, finalPackage, { encoding: 'utf8' });
            cli_utils_1.fsUnlink(patchPackagePath);
        }
        catch (e) {
            if (e === cli_utils_1.ERROR_FILE_NOT_FOUND) {
            }
            else if (e === cli_utils_1.ERROR_FILE_INVALID_JSON) {
                throw new Error(`${patchPackagePath} is not valid JSON.`);
            }
            else {
                throw e;
            }
        }
    });
}
exports.patchPackageJsonForCli = patchPackageJsonForCli;
function updatePackageJsonForCli(appName, starterType, pathToProject) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = path.resolve(pathToProject, 'package.json');
        try {
            let jsonStructure = yield cli_utils_1.fsReadJsonFile(filePath);
            jsonStructure['name'] = appName;
            jsonStructure['version'] = '0.0.1';
            jsonStructure['description'] = 'An Ionic project';
            yield cli_utils_1.fsWriteJsonFile(filePath, jsonStructure, { encoding: 'utf8' });
        }
        catch (e) {
            if (e === cli_utils_1.ERROR_FILE_NOT_FOUND) {
                throw new Error(`${filePath} not found`);
            }
            else if (e === cli_utils_1.ERROR_FILE_INVALID_JSON) {
                throw new Error(`${filePath} is not valid JSON.`);
            }
            throw e;
        }
    });
}
exports.updatePackageJsonForCli = updatePackageJsonForCli;
function createProjectConfig(appName, starterType, pathToProject, cloudAppId) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = path.resolve(pathToProject, 'ionic.config.json');
        const jsonStructure = {
            name: appName,
            app_id: cloudAppId,
            type: starterType.id
        };
        yield cli_utils_1.fsWriteJsonFile(filePath, jsonStructure, { encoding: 'utf8' });
    });
}
exports.createProjectConfig = createProjectConfig;
