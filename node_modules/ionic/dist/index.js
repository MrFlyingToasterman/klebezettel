"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const minimist = require("minimist");
const chalk = require("chalk");
const cli_utils_1 = require("@ionic/cli-utils");
const commands_1 = require("./commands");
exports.name = 'ionic';
exports.version = '3.4.0';
exports.namespace = new commands_1.IonicNamespace();
const BUILD_BEFORE_HOOK = 'build:before';
const BUILD_BEFORE_SCRIPT = `ionic:${BUILD_BEFORE_HOOK}`;
const BUILD_AFTER_HOOK = 'build:after';
const BUILD_AFTER_SCRIPT = `ionic:${BUILD_AFTER_HOOK}`;
const WATCH_BEFORE_HOOK = 'watch:before';
const WATCH_BEFORE_SCRIPT = `ionic:${WATCH_BEFORE_HOOK}`;
function registerHooks(hooks) {
    hooks.register(exports.name, BUILD_BEFORE_HOOK, ({ env }) => __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield env.project.loadPackageJson();
        if (packageJson.scripts && packageJson.scripts[BUILD_BEFORE_SCRIPT]) {
            env.log.debug(`Invoking ${chalk.cyan(BUILD_BEFORE_SCRIPT)} npm script.`);
            yield env.shell.run('npm', ['run', BUILD_BEFORE_SCRIPT], {});
        }
    }));
    hooks.register(exports.name, BUILD_AFTER_HOOK, ({ env }) => __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield env.project.loadPackageJson();
        if (packageJson.scripts && packageJson.scripts[BUILD_AFTER_SCRIPT]) {
            env.log.debug(`Invoking ${chalk.cyan(BUILD_AFTER_SCRIPT)} npm script.`);
            yield env.shell.run('npm', ['run', BUILD_AFTER_SCRIPT], {});
        }
    }));
    hooks.register(exports.name, WATCH_BEFORE_HOOK, ({ env }) => __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield env.project.loadPackageJson();
        if (packageJson.scripts && packageJson.scripts[WATCH_BEFORE_SCRIPT]) {
            env.log.debug(`Invoking ${chalk.cyan(WATCH_BEFORE_SCRIPT)} npm script.`);
            yield env.shell.run('npm', ['run', WATCH_BEFORE_SCRIPT], {});
        }
    }));
    hooks.register(exports.name, 'command:info', () => __awaiter(this, void 0, void 0, function* () {
        const osName = cli_utils_1.load('os-name');
        const os = osName();
        const node = process.version;
        const [npm, xcode, iosDeploy, iosSim,] = yield Promise.all([
            cli_utils_1.getCommandInfo('npm', ['-v']),
            cli_utils_1.getCommandInfo('/usr/bin/xcodebuild', ['-version']),
            cli_utils_1.getCommandInfo('ios-deploy', ['--version']),
            cli_utils_1.getCommandInfo('ios-sim', ['--version']),
        ]);
        return [
            { type: 'global-packages', name: 'Ionic CLI', version: exports.version },
            { type: 'system', name: 'Node', version: node },
            { type: 'system', name: 'npm', version: npm || 'not installed' },
            { type: 'system', name: 'OS', version: os },
            { type: 'system', name: 'Xcode', version: xcode || 'not installed' },
            { type: 'system', name: 'ios-deploy', version: iosDeploy || 'not installed' },
            { type: 'system', name: 'ios-sim', version: iosSim || 'not installed' },
        ];
    }));
}
exports.registerHooks = registerHooks;
function generateIonicEnvironment(pargv, env) {
    return __awaiter(this, void 0, void 0, function* () {
        env['IONIC_CLI_LIB'] = __filename;
        env['IONIC_PROJECT_FILE'] = cli_utils_1.PROJECT_FILE;
        env['IONIC_PROJECT_DIR'] = yield getProjectRootDir(process.cwd(), cli_utils_1.PROJECT_FILE);
        const argv = minimist(pargv, { boolean: true });
        argv._ = argv._.map(i => String(i));
        const config = new cli_utils_1.Config(env['IONIC_CONFIG_DIRECTORY'] || cli_utils_1.CONFIG_DIRECTORY, cli_utils_1.CONFIG_FILE);
        const changedFlags = yield cli_utils_1.handleCliFlags(config, argv);
        const configData = yield config.load();
        let stream;
        let tasks;
        let bottomBar;
        let log;
        if (configData.cliFlags['interactive']) {
            const inquirer = cli_utils_1.load('inquirer');
            bottomBar = new inquirer.ui.BottomBar();
            try {
                const bottomBarHack = bottomBar;
                bottomBarHack.rl.output.mute();
            }
            catch (e) {
                console.error('EXCEPTION DURING BOTTOMBAR OUTPUT MUTE', e);
            }
            stream = bottomBar.log;
            log = new cli_utils_1.Logger({ stream });
            tasks = new cli_utils_1.InteractiveTaskChain({ log, bottomBar });
        }
        else {
            stream = process.stdout;
            log = new cli_utils_1.Logger({ stream });
            tasks = new cli_utils_1.TaskChain({ log });
        }
        for (let [flag, newValue] of changedFlags) {
            const prettyFlag = chalk.green('--' + (newValue ? '' : 'no-') + flag);
            log.info(`CLI Flag ${prettyFlag} saved`);
            if (flag === 'telemetry' && newValue) {
                log.msg('Thank you for making the CLI better! ❤️');
            }
            else if (flag === 'confirm' && newValue) {
                log.warn(`Careful with ${prettyFlag}. Some auto-confirmed actions are destructive.`);
            }
        }
        const project = new cli_utils_1.Project(env['IONIC_PROJECT_DIR'], cli_utils_1.PROJECT_FILE);
        const hooks = new cli_utils_1.HookEngine();
        const client = new cli_utils_1.Client(configData.urls.api);
        const telemetry = new cli_utils_1.Telemetry(config, exports.version);
        const shell = new cli_utils_1.Shell(tasks, log);
        const session = new cli_utils_1.Session(config, project, client);
        const app = new cli_utils_1.App(session, project, client);
        registerHooks(hooks);
        cli_utils_1.registerHooks(hooks);
        return {
            app,
            argv,
            client,
            close() {
                tasks.cleanup();
                if (bottomBar) {
                    bottomBar.close();
                    log.stream = process.stdout;
                }
            },
            config,
            events: new cli_utils_1.CLIEventEmitter,
            hooks,
            load: cli_utils_1.load,
            log,
            namespace: exports.namespace,
            pargv,
            plugins: {
                ionic: {
                    name: exports.name,
                    version: exports.version,
                    namespace: exports.namespace,
                    registerHooks,
                    meta: {
                        filePath: __filename,
                    }
                },
            },
            prompt: yield cli_utils_1.createPromptModule(log, config),
            project,
            session,
            shell,
            tasks,
            telemetry,
        };
    });
}
exports.generateIonicEnvironment = generateIonicEnvironment;
function run(pargv, env) {
    return __awaiter(this, void 0, void 0, function* () {
        const now = new Date();
        let exitCode = 0;
        let err;
        const ienv = yield generateIonicEnvironment(modifyArguments(pargv.slice(2)), env);
        try {
            const configData = yield ienv.config.load();
            if (ienv.argv['log-level']) {
                ienv.log.level = ienv.argv['log-level'];
            }
            if (env['IONIC_EMAIL'] && env['IONIC_PASSWORD']) {
                ienv.log.debug(`${chalk.bold('IONIC_EMAIL')} / ${chalk.bold('IONIC_PASSWORD')} environment variables detected`);
                if (configData.user.email !== env['IONIC_EMAIL']) {
                    ienv.log.debug(`${chalk.bold('IONIC_EMAIL')} mismatch with current session--attempting login`);
                    try {
                        yield ienv.session.login(env['IONIC_EMAIL'], env['IONIC_PASSWORD']);
                    }
                    catch (e) {
                        ienv.log.error(`Error occurred during automatic login via ${chalk.bold('IONIC_EMAIL')} / ${chalk.bold('IONIC_PASSWORD')} environment variables.`);
                        throw e;
                    }
                }
            }
            if (ienv.project.directory) {
                const nodeModulesExists = yield cli_utils_1.pathExists(path.join(ienv.project.directory, 'node_modules'));
                if (!nodeModulesExists) {
                    const confirm = yield ienv.prompt({
                        type: 'confirm',
                        name: 'confirm',
                        message: `Looks like a fresh checkout! No ${chalk.green('./node_modules')} directory found. Would you like to install project dependencies?`,
                    });
                    if (confirm) {
                        ienv.log.info('Installing dependencies may take several minutes!');
                        const [installer, ...installerArgs] = yield cli_utils_1.pkgManagerArgs(ienv, { command: 'install' });
                        yield ienv.shell.run(installer, installerArgs, {});
                    }
                }
            }
            const foundCommand = mapLegacyCommand(ienv.argv._[0]);
            if (foundCommand) {
                ienv.log.msg(`The ${chalk.green(ienv.argv._[0])} command has been renamed. To find out more, run:\n\n` +
                    `  ${chalk.green(`ionic ${foundCommand} --help`)}\n\n`);
            }
            else {
                let updates;
                try {
                    yield cli_utils_1.loadPlugins(ienv);
                }
                catch (e) {
                    if (e.fatal) {
                        throw e;
                    }
                    ienv.log.error(chalk.red.bold('Error occurred while loading plugins. CLI functionality may be limited.\nChecking for CLI updates now...'));
                    ienv.log.debug(chalk.red(chalk.bold('Plugin error: ') + (e.stack ? e.stack : e)));
                    updates = yield cli_utils_1.checkForUpdates(ienv);
                    if (updates.length === 0) {
                        ienv.log.error('No updates found after plugin error--please report this issue.');
                    }
                }
                yield ienv.hooks.fire('plugins:init', { env: ienv });
                if (configData.cliFlags['dev-always-ionic-updates'] || configData.cliFlags['dev-always-plugin-updates'] || (typeof updates === 'undefined' && now.getTime() - new Date(configData.lastCommand).getTime() >= 3600000)) {
                    yield cli_utils_1.checkForUpdates(ienv);
                }
                yield exports.namespace.runCommand(ienv);
                configData.lastCommand = now.toISOString();
            }
        }
        catch (e) {
            ienv.log.debug(chalk.red.bold('!!! ERROR ENCOUNTERED !!!'));
            err = e;
        }
        try {
            yield Promise.all([ienv.config.save(), ienv.project.save()]);
        }
        catch (e) {
            ienv.log.error(e);
        }
        if (err) {
            ienv.tasks.fail();
            exitCode = 1;
            if (cli_utils_1.isValidationErrorArray(err)) {
                for (let e of err) {
                    ienv.log.error(e.message);
                }
                ienv.log.msg(`Use the ${chalk.green('--help')} flag for more details.`);
            }
            else if (cli_utils_1.isSuperAgentError(err)) {
                ienv.log.msg(cli_utils_1.formatSuperAgentError(err));
            }
            else if (err.fatal) {
                exitCode = typeof err.exitCode === 'number' ? err.exitCode : 1;
                if (err.message) {
                    if (exitCode > 0) {
                        ienv.log.error(err.message);
                    }
                    else {
                        ienv.log.msg(err.message);
                    }
                }
            }
            else {
                ienv.log.msg(chalk.red(String(err)));
                if (err.stack) {
                    ienv.log.debug(chalk.red(err.stack));
                }
            }
            process.exit(exitCode);
        }
        ienv.close();
    });
}
exports.run = run;
function getProjectRootDir(dir, projectFileName) {
    return __awaiter(this, void 0, void 0, function* () {
        dir = path.normalize(dir);
        const dirInfo = path.parse(dir);
        const directoriesToCheck = dirInfo.dir
            .slice(dirInfo.root.length)
            .split(path.sep)
            .concat(dirInfo.base)
            .map((segment, index, array) => {
            let pathSegments = array.slice(0, (array.length - index));
            return dirInfo.root + path.join(...pathSegments);
        });
        for (let i = 0; i < directoriesToCheck.length; i++) {
            const results = yield cli_utils_1.fsReadDir(directoriesToCheck[i]);
            if (results.includes(projectFileName)) {
                return directoriesToCheck[i];
            }
        }
        return '';
    });
}
exports.getProjectRootDir = getProjectRootDir;
function modifyArguments(pargv) {
    let modifiedArgArray = pargv.slice();
    const minimistArgv = minimist(pargv, { boolean: true });
    if (pargv.length === 0) {
        return ['help'];
    }
    if (minimistArgv['help'] || minimistArgv['h']) {
        if (minimistArgv._.length > 0) {
            return ['help', ...minimistArgv._];
        }
        else {
            return ['help'];
        }
    }
    if (minimistArgv._.length === 0 && (minimistArgv['version'] || minimistArgv['v'])) {
        return ['version'];
    }
    if (minimistArgv._[0] === 'lab') {
        modifiedArgArray[0] = 'serve';
        modifiedArgArray.push('--lab');
    }
    if (minimistArgv['verbose']) {
        modifiedArgArray[modifiedArgArray.indexOf('--verbose')] = '--log-level=debug';
    }
    if (minimistArgv['quiet']) {
        modifiedArgArray[modifiedArgArray.indexOf('--quiet')] = '--log-level=warn';
    }
    return modifiedArgArray;
}
exports.modifyArguments = modifyArguments;
function mapLegacyCommand(command) {
    const commandMap = {
        'build': 'cordova build',
        'compile': 'cordova compile',
        'emulate': 'cordova emulate',
        'platform': 'cordova platform',
        'plugin': 'cordova plugin',
        'prepare': 'cordova prepare',
        'resources': 'cordova resources',
        'run': 'cordova run',
        'cordova:build': 'cordova build',
        'cordova:compile': 'cordova compile',
        'cordova:emulate': 'cordova emulate',
        'cordova:platform': 'cordova platform',
        'cordova:plugin': 'cordova plugin',
        'cordova:prepare': 'cordova prepare',
        'cordova:resources': 'cordova resources',
        'cordova:run': 'cordova run',
    };
    return commandMap[command];
}
